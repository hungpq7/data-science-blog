{
  
    
        "post0": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://hungpq7.github.io/data-science-blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Graph Construction",
            "content": "1. Matplotlib API . Matplotlib is a famous visualization library in Python, is the foundation for many other visualization libraries. Matplotlib along with NumPy can be considered equivalent to Matlab. . This topic focuses only on Pyplot - the most essential sub-module of Matplotlib and how to use it to build graphs of mathematical functions. For data visualization plots such as bar chart, histogram or pie chart, there are other libraries that do a better job than Matplotlib, and they will be discussed on later topics. . 1.1. Plotting interfaces . import numpy as np import matplotlib.pyplot as plt plt.style.use([&#39;seaborn&#39;, &#39;seaborn-whitegrid&#39;]) %config InlineBackend.figure_format = &#39;retina&#39; . Object-oriented interface . Every plot created by Matplotlib is under the control of two objects, figure and axes. . An figure object is the whole image generated by Matplotlib, where everything is drawn on. It is a top-level object and works as a container for a number of axes objects. | Each axes object usually refers to a 2-dimensional Cartesian coordinate system. It gives access to plot elements such as plots, labels, titles, text. | . fig = plt.figure(figsize=(4,3)) # add an axes with some text ax = fig.add_subplot() ax.text(0.5, 0.5, &#39;DATA&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, size=20) plt.show() . Instead of creating figure and axes independently, Matplotlib provides a single function subplots() creates the two objects at once. This function is highly recommended in practice, and the introduction to the previous method is to clarify how figure and axes work and how they are related. . fig, ax = plt.subplots(figsize=(4,3)) ax.text(0.5, 0.5, &#39;DATA&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, size=20) plt.show() . When there are more than one axes, Matplotlib arranges them in a matrix of axes objects. Accessing each axes can be done using NumPy&#39;s array slicing. . fig, ax = plt.subplots(nrows=2, ncols=3, figsize=(12,6), sharex=True, sharey=True) ax[0,2].text(0.5, 0.5, &#39;Row = 0 nColumn = 2&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, size=20) ax[1,1].text(0.5, 0.5, &#39;Row = 1 nColumn = 1&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, size=20) plt.show() . State-machine interface . Besides the object-oriented interface, Matplotlib also provides another way that makes use of state-machine to create plots. When using this, the state-machine implicitly and automatically creates figures and axes to achieve the desired plot. Then a set of simple functions is used to add plot elements to the current axes in the current figure. . Compared to object-oriented, state-machine interface is a bit more convenient for making a single axes, but it is not recommended for arranging multiple axes. Overall, object-oriented interface is still the go-to method. . plt.text(0.5, 0.5, &#39;Data&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, size=32) plt.axvline(x=0.5, lw=1, color=&#39;g&#39;, linestyle=&#39;--&#39;) plt.axhline(y=0.5, lw=1, color=&#39;g&#39;, linestyle=&#39;--&#39;) plt.title(&#39;State-machine interface&#39;) plt.show() . 1.2. Controlling axes . import numpy as np import matplotlib.pyplot as plt plt.style.use([&#39;seaborn&#39;, &#39;seaborn-whitegrid&#39;]) %config InlineBackend.figure_format = &#39;retina&#39; . Equalizing axes . Graphs require the two axes to have the same scale. . fig, ax = plt.subplots() # make the two axes scaled ax.axis(&#39;scaled&#39;) # set tick frequencies of both axes to be 0.02 ax.xaxis.set_major_locator(plt.MultipleLocator(0.02)) ax.yaxis.set_major_locator(plt.MultipleLocator(0.02)) plt.show() . Axes limits . fig, ax = plt.subplots() ax.axis(&#39;scaled&#39;) # set limit for each axis ax.set_xlim(0, 2) ax.set_ylim(0, 1) ax.xaxis.set_major_locator(plt.MultipleLocator(0.2)) plt.show() . Formatting axes . def axis_formatter(value, tick): N = int(np.round(2 * value / np.pi)) if N == 0: return &quot;0&quot; elif N == 2: return r&quot;$ pi$&quot; elif N == -2: return r&#39;$- pi$&#39; elif N % 2 == 1 and N &gt; 0: return fr&quot;$ frac{{{N}}}{{2}} pi$&quot; elif N % 2 == 1 and N &lt; 0: return fr&quot;$- frac{{{-N}}}{{2}} pi$&quot; else: return fr&quot;${N//2} pi$&quot; . x = np.linspace(-5, 10, 1000) y = np.sin(x) + np.sin(2*x) fig, ax = plt.subplots(figsize=(10,10)) ax.plot(x, y, &#39;k&#39;) ax.axis(&#39;scaled&#39;) # set x-tick frequency to be pi/2 and apply a custom format strategy ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/2)) ax.xaxis.set_major_formatter(plt.FuncFormatter(axis_formatter)) ax.set_ylim(-2.5, 2.5) plt.show() . 1.3. Plotting . import numpy as np import matplotlib.pyplot as plt plt.style.use([&#39;seaborn&#39;, &#39;seaborn-whitegrid&#39;]) %config InlineBackend.figure_format = &#39;retina&#39; . Graphs . Matplotlib does not really have a way to make graphs, but this can be achieved indirectly by using the axes.plot() method. The original functionality of this function is to plot a polyline connects data points. . It has an optional parameter, fmt that defines basic formatting following the syntax: &#39;{marker}{linestyle}{color}&#39;. The formatting string must not strictly follow the order in the syntax, but note that the parsing may be ambiguous. The table below summarizes some useful formatting strings: . Parameter Character Meaning . marker | &#39;.&#39; | point marker | . marker | &#39;o&#39; | big point marker | . linestyle | &#39;-&#39; | solid line style | . linestyle | &#39;--&#39; | dashed line style | . linestyle | &#39;:&#39; | dotted line style | . linestyle | &#39;-.&#39; | dash-dot line style | . color | &#39;k&#39; | black | . color | &#39;r&#39; | red | . color | &#39;c&#39; | cyan | . color | &#39;m&#39; | magenta | . color | &#39;g&#39; | green | . With different combinations of formatting strings, axes.plot() can result in graphs (indirectly) and points (directly). In order to make graphs, the input for x-axis needs to be a dense set of values. . x1 = np.linspace(-5, 10, 1000) y1 = np.sin(x1) + np.sin(2*x1) x2 = np.array([0, 4, 5.5, -4]) y2 = np.array([1, 2, 0, -2]) fig, ax = plt.subplots(figsize=(10,4)) ax.plot(x1, y1, &#39;k&#39;) ax.plot(x2, y2, &#39;oc&#39;) ax.axis(&#39;scaled&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) plt.show() . Spans . x = np.linspace(-5, 10, 1000) y = np.sin(x) + np.sin(2*x) fig, ax = plt.subplots(figsize=(12,4)) # add two lines represent the two axes ax.axhline(y=0, c=&#39;grey&#39;) ax.axvline(x=0, c=&#39;grey&#39;) # add a vertical span across y-axis ax.axvspan(xmin=4.5, xmax=6.5, alpha=0.3) ax.plot(x, y, &#39;k&#39;) ax.axis(&#39;scaled&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) plt.show() . Vectors . The axes.quiver() method in Matplotlib allows plotting vectors. It has five important parameters, which must have the same length: . X and Y locate the origins of vectors | U and V define the vectors | color sets vector colors | . For some reasons, the parameters units=&#39;xy&#39; and scale=1 must always be set in order to draw vectors correctly. . fig, ax = plt.subplots() ax.axhline(y=0, c=&#39;grey&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.quiver( [1, 0, 2], [1, 0, 0], [1, -3, -4], [2, 1, -2], color=[&#39;firebrick&#39;, &#39;teal&#39;, &#39;seagreen&#39;], units=&#39;xy&#39;, scale=1 ) ax.axis(&#39;scaled&#39;) ax.set_xlim(-4,3) ax.set_ylim(-3,4) plt.show() . 1.4. Annotations . import numpy as np import matplotlib.pyplot as plt plt.style.use([&#39;seaborn&#39;, &#39;seaborn-whitegrid&#39;]) %config InlineBackend.figure_format = &#39;retina&#39; . Text positioning . The axes.text() method adds text to the axes at the location defined by two parameters, x and y, use true coordinate values by default. By setting transform=ax.transAxes (highly recommended), these two parameters are now on a relative coordinates where (0,0) is the lower-left corner and (1,1) is the upper-right corner. . There is also a pair of parameters, ha and va (horizontal/vertical alignment), specify the relative position of the coordinates to the text box. Possible values for these parameters are left right center and top bottom center, respectively. . fig, ax = plt.subplots(figsize=(5,5)) ax.text(0.5, 0.5, &#39;(0.5, 0.5) ncenter center&#39;, va=&#39;center&#39;, ha=&#39;center&#39;, size=14, transform=ax.transAxes) ax.text(0, 0, &#39;(0, 0) nbottom left&#39;, va=&#39;bottom&#39;, ha=&#39;left&#39;, size=14, transform=ax.transAxes) ax.text(1, 1, &#39;(1, 1) ntop right&#39;, va=&#39;top&#39;, ha=&#39;right&#39;, size=14, transform=ax.transAxes) ax.text(0, 1, &#39;(0, 1) ntop left&#39;, va=&#39;top&#39;, ha=&#39;left&#39;, size=14, transform=ax.transAxes) ax.text(1, 0, &#39;(1, 0) nbottom right&#39;, va=&#39;bottom&#39;, ha=&#39;right&#39;, size=14, transform=ax.transAxes) ax.axis(&#39;scaled&#39;) ax.xaxis.set_major_formatter(plt.NullFormatter()) ax.yaxis.set_major_formatter(plt.NullFormatter()) plt.show() . Plot titles . x = np.linspace(-1, 8, 1000) fig, ax = plt.subplots(nrows=2, sharex=True, figsize=(5,7)) fig.suptitle(&#39;Mathematics&#39;, fontsize=16) ax[0].plot(x, np.sin(x)+2*np.sin(2*x), &#39;k&#39;) ax[0].set_title(&#39;$y= sin(x)+2 sin(x)$&#39;) ax[0].axis(&#39;equal&#39;) ax[0].xaxis.set_major_locator(plt.MultipleLocator(1)) ax[0].yaxis.set_major_locator(plt.MultipleLocator(1)) ax[1].plot(x, np.sin(x*2*np.pi)*np.exp(-x), &#39;k&#39;) ax[1].set_title(&#39;$y= sin(x2 pi) cdot e^{-x}$&#39;) ax[1].axis(&#39;scaled&#39;) ax[1].xaxis.set_major_locator(plt.MultipleLocator(1)) ax[1].yaxis.set_major_locator(plt.MultipleLocator(1)) plt.show() . Axis labels . x = np.linspace(-1, 4, 1000) fig, ax = plt.subplots() ax.plot(x, np.sin(x*2*np.pi)*np.exp(-x), &#39;k&#39;) ax.axis(&#39;scaled&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) # set axis labels ax.set_xlabel(&#39;x-axis&#39;) ax.set_ylabel(&#39;y-axis&#39;) plt.show() . Legends . The axes.lengend() method takes a list of plot names, which is indexed the same as the number of axes.plot() methods called. It can also use the value of label parameter in each axes.plot() method to generate the legend. . By default, Matplotlib automatically determines the best location for the legend inside the plot. This can be changed using the parameter loc, which specifies locations using strings such as &quot;lower center&quot; and &quot;upper right&quot;. When there is no optimized location like in the example below, the legend should be placed outside of the axes. This can be achieved using bbox_to_anchor alongside with loc; this pair of parameters behaves exactly the same as text positioning. . Another useful configuration is the ncol parameter. It specifies the number of columns in the grid of legend labels. . x = np.linspace(-4, 4, 1000) fig, ax = plt.subplots() ax.plot(x, np.sin(x), &#39;:k&#39;) ax.plot(x, np.sin(2*x), &#39;--k&#39;) ax.plot(x, np.sin(x)+np.sin(2*x), &#39;r&#39;) ax.axis(&#39;scaled&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axhline(y=0, c=&#39;grey&#39;) ax.axvline(x=0, c=&#39;grey&#39;) # pass the list of labels into the ax.legend method ax.legend([&#39;$ sin(x)$&#39;, &#39;$ sin(2x)$&#39;, &#39;$ sin(x)+ sin(2x)$&#39;], bbox_to_anchor=(1, 0.5), loc=&#39;center left&#39;) plt.show() . x = np.linspace(-4, 4, 1000) fig, ax = plt.subplots() ax.plot(x, np.sin(x), &#39;:k&#39;, label=&#39;$ sin(x)$&#39;) ax.plot(x, np.sin(2*x), &#39;--k&#39;, label=&#39;$ sin(2x)$&#39;) ax.plot(x, np.sin(x)+np.sin(2*x), &#39;r&#39;, label=&#39;$ sin(x)+ sin(2x)$&#39;) ax.axis(&#39;scaled&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axhline(y=0, c=&#39;grey&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.legend(bbox_to_anchor=(0.5, 1), loc=&#39;lower center&#39;, ncol=3, title=&#39;Graphs&#39;) plt.show() . 1.5. Themes and colors . import numpy as np import matplotlib.pyplot as plt plt.style.use([&#39;seaborn&#39;, &#39;seaborn-whitegrid&#39;]) %config InlineBackend.figure_format = &#39;retina&#39; . Themes . Matplotlib supports a variety of themes such as ggplot seaborn tableau-colorblind10 inspired by other popular visualization tools. However, since drawing graphs requires a white background, then I usually use seaborn-whitegrid. . plt.style.use(&#39;ggplot&#39;) x = np.linspace(-4, 4, 1000) fig, ax = plt.subplots() ax.plot(x, np.sin(x)) ax.plot(x, np.sin(2*x)) ax.plot(x, np.sin(x)+np.sin(2*x)) ax.axis(&#39;scaled&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axhline(y=0, c=&#39;grey&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.legend([&#39;$ sin(x)$&#39;, &#39;$ sin(2x)$&#39;, &#39;$ sin(x)+ sin(2x)$&#39;], bbox_to_anchor=(1, 0.5), loc=&#39;center left&#39;) plt.show() . plt.style.use(&#39;seaborn&#39;) x = np.linspace(-4, 4, 1000) fig, ax = plt.subplots() ax.plot(x, np.sin(x)) ax.plot(x, np.sin(2*x)) ax.plot(x, np.sin(x)+np.sin(2*x)) ax.axis(&#39;scaled&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axhline(y=0, c=&#39;grey&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.legend([&#39;$ sin(x)$&#39;, &#39;$ sin(2x)$&#39;, &#39;$ sin(x)+ sin(2x)$&#39;], bbox_to_anchor=(1, 0.5), loc=&#39;center left&#39;) plt.show() . Built-in Matplotlib colors . Besides themes, Matplotlib also provides a collection of colors for better visualization. Some nice colors are: dimgrey indianred tomato goldenrod seagreen teal darkturquoise darkslategrey slategrey royalblue rebeccapurple. . . 2. Mathematical functions . In Mathematics, a function) (usually denoted $f$) is a process of transforming each given input number (denoted $x$) to exactly one output number (denoted $y$). This process can be in the form of a mathematical formula or some logical rules and can be expressed using the notation: . $$y=f(x)$$ . The set of inputs and the set of outputs are called the domain (denoted $X$) and codomain (denoted $Y$), consecutively. The function in this context is written as $f colon X to Y$. . The set of all pairs $(x,y)$, formally denoted $G= {(x,y) mid x in X }$ is called the graph of the function. It popularly means the illustration of the function with the condition $x,y in mathbb{R}$. . Another related concept to function is map), which is often used as a synonym of function. However, from now on in this series about Data Science, map refers to a generalization of function, which extends the scope of $x$ and $y$ not to be restricted to numbers only, but can also be other data-like objects such as strings and datetime. In reality, the more common meaning of the word map, Google Maps, for example, is actually made by mapping the Earth&#39;s surface to a sheet of paper. The notation for map is: . $$f colon x mapsto y$$ . 2.1. Elementary functions . import numpy as np import matplotlib.pyplot as plt plt.style.use([&#39;seaborn&#39;, &#39;seaborn-whitegrid&#39;]) %config InlineBackend.figure_format = &#39;retina&#39; . Polynomial functions . A polynomial is a function having the following form: . $$y=a_nx^n+a_{n-1}x^{n-1}+a_{n-2}x^{n-2}+ dots+a_1x+a_0$$ . where: . $n ;(n in mathbb{N})$ is the degree of the polynomial | $n,n-1,n-2, dots,0$ are the degrees of the corresponding monomial | $a_n,a_{n-1}, dots,a_0 ;(a_n neq0)$ are the coefficients | . Each polynomial has the domain of $x in mathbb{R}$ and the codomain of $y in mathbb{R}$. It has a maximum of $n$ solutions and a maximum of $n-1$ extrema. . Some popular polynomials are: . $f(x)=ax+b$, linear functions | $f(x)=ax^2+bx+c$, quadratic functions, which has the parabola shape | . x = np.linspace(-5, 4, 1000) y1 = x**2 + 4*x + 2 y2 = 1/4*x**3 + 3/4*x**2 - 3/2*x fig, ax = plt.subplots() ax.plot(x, y1, label=&#39;Quadratic (degree 2)&#39;) ax.plot(x, y2, label=&#39;Cubic (degree 3)&#39;, c=&#39;indianred&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_ylim(-3, 6) ax.legend() plt.show() . Exponential functions . An exponential function is a function having $x$ in its power. The form of the function is: . $$y=b^x$$ . where $b ;(b&gt;0)$ is the base. . Exponential functions have the domain of $x in mathbb{R}$ and the codomain of $y in(0,+ infty)$. Exponential functions are monotonic, and can be either increasing or decreasing as the value of $b$ changes. All exponential functions go through the point $(0,1)$, since $b^0=1$ for any value of $b$. . Some popular exponential functions are: . $f(x)=2^x$, the foundation of binary system being used in almost all modern computers | $f(x)=10^x$, the foundation of decimal numeral system | $f(x)=e^x= exp{(x)}$, the natural) exponential function, the function equals to its own derivative | . x = np.linspace(-5, 5, 1000) y1 = 2**x y2 = np.e**x y3 = 10**x y4 = (1/2)**x fig, ax = plt.subplots() ax.plot(x, y1, label=&#39;$y=2^x$&#39;) ax.plot(x, y2, label=&#39;$y=e^x$&#39;) ax.plot(x, y3, label=&#39;$y=10^x$&#39;) ax.plot(x, y4, label=&#39;$y=0.5^x$&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-4, 4) ax.set_ylim(-1, 7) ax.legend(bbox_to_anchor=(1, 0.5), loc=&#39;center left&#39;) plt.show() . Logarithm functions . Logarithm is the inverse function of exponentiation. With a given base $b ;(b&gt;0)$, logarithm functions have the following form: . $$y= log_b{x}$$ . The domain of the logarithm functions is $x in(0,+ infty)$. Popular logarithm functions are: . $f(x)= log_2{x}$, the binary logarithm | $f(x)= log_{10}{x}= lg{x}$, the common logarithm | $f(x)= log_e{x}= ln{x}= log{x}$, the natural logarithm | . Notice that in many Python libraries, the log function refers to the natural logarithm instead of base 10. . x = np.linspace(1e-6, 10, 1000) y1 = np.log2(x) y2 = np.log10(x) y3 = np.log(x) fig, ax = plt.subplots() ax.plot(x, y1, label=&#39;$y= log_2{x}$&#39;) ax.plot(x, y2, label=&#39;$y= log_{10}{x}$&#39;) ax.plot(x, y3, label=&#39;$y= ln{x}$&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(0, 9) ax.set_ylim(-3, 3) ax.legend() plt.show() . Power functions . Power functions are a family of functions having $x$ in their bases, they should not be confused with exponential functions. The most common type of power function being applied in Data Science is the ones with a natural exponent: . $$y=x^n$$ . where $n ;(n in mathbb{N})$ is the exponent. . The domain of power functions is $x in mathbb{R}$. If $n$ is even, the function is reflectional symmetric since $f(x)=f(-x)$; if $n$ is odd, the function is rotationally symmetric since $f(x)=-f(-x)$. Some popular named functions of this type are: . $f(x)=x^2$, the square function), applied in calculating the area | $f(x)=x^3$, the cube function), applied in calculating the volume | . x = np.linspace(-5, 5, 1000) y1 = x**2 y2 = x**5 fig, ax = plt.subplots() ax.plot(x, y1, label=&#39;$y=x^2$&#39;) ax.plot(x, y2, label=&#39;$y=x^5$&#39;, c=&#39;indianred&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-3, 3) ax.set_ylim(-4, 4) ax.legend() plt.show() . Root functions . Root functions are power functions having rational exponents: . $$y=x^{a/b}= sqrt[b]{x^a} ;(a,b in mathbb{N})$$ . The domain of root functions is $x geq0$ for even values of $b$ and is $x in mathbb{R}$ for odd values of $b$. Some popular root functions are: . $f(x)= sqrt{x}$, the square root function | $f(x)= sqrt[3]{x}$, the cube root function | . x1 = np.linspace(0, 5, 1000) y1 = np.sqrt(x1) x2 = np.linspace(-5, 5, 1000) y2 = np.cbrt(x2) fig, ax = plt.subplots() ax.plot(x1, y1, label=&#39;$y=x^2$&#39;) ax.plot(x2, y2, label=&#39;$y=x^5$&#39;, c=&#39;indianred&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-5, 5) ax.set_ylim(-2.5, 2.5) ax.legend() plt.show() . Reciprocal functions . Reciprocal function is a special case of power function, when the exponent is a negative rational number: . $$y=x^{-q}= frac{1}{x^q} ;(q in mathbb{Q})$$ . The domain of reciprocal functions is $x neq0$. They also have symmetric properties like natural power functions. The term reciprocal usually refers to the most common case, $f(x)=x^{-1}$, which has a beautiful property: $x cdot x^{-1}=1$. . x = np.linspace(-5, 5, 1000) y = 1/x fig, ax = plt.subplots() ax.plot(x, y, &#39;k&#39;, label=&#39;$y=x^{-1}$&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-5, 5) ax.set_ylim(-5, 5) ax.legend() plt.show() . Trigonometric functions . Three most used trigonometric functions in modern Mathematics are the sine ($y= sin{x}$), the cosine ($y= cos{x}$) and the tangent ($y= tan{x}$). They are defined on the unit circle $x^2+y^2=1$. Since all trigonometric functions are periodic, the visualization for them is limited to be in the domain $x in(-2 pi,2 pi)$. . x = np.linspace(-2*np.pi, 2*np.pi, 1000) y1 = np.sin(x) y2 = np.cos(x) fig, ax = plt.subplots() ax.plot(x, y1, label=&#39;$y= sin(x)$&#39;) ax.plot(x, y2, label=&#39;$y= cos(x)$&#39;, c=&#39;indianred&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-2*np.pi, 2*np.pi) ax.set_ylim(-1.5, 1.5) ax.legend(bbox_to_anchor=(1, 0.5), loc=&#39;center left&#39;) plt.show() . Hyperbolic functions . Hyperbolic functions are trigonometric functions defined using the unit hyperbola $x^2-y^2=1$ rather than the circle. The formulas for the three most popular hyperbolic functions are: . $ displaystyle{ sinh{x}= frac{e^x-e^{-x}}{2}}$ . | $ displaystyle{ cosh{x}= frac{e^x+e^{-x}}{2}}$ . | $ displaystyle{ tanh{x}= frac{ sinh{x}}{ cosh{x}}= frac{e^x-e^{-x}}{e^x+e^{-x}}}$ . | . x = np.linspace(-5, 5, 1000) y1 = np.sinh(x) y2 = np.cosh(x) y3 = np.tanh(x) fig, ax = plt.subplots() ax.plot(x, y1, label=&#39;$y= sinh(x)$&#39;) ax.plot(x, y2, label=&#39;$y= cosh(x)$&#39;) ax.plot(x, y3, label=&#39;$y= tanh(x)$&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-4, 4) ax.set_ylim(-4, 4) ax.legend() plt.show() . 2.2. Function transformations . import numpy as np import matplotlib.pyplot as plt plt.style.use([&#39;seaborn&#39;, &#39;seaborn-whitegrid&#39;]) %config InlineBackend.figure_format = &#39;retina&#39; . Translation . Translation) refers to the process of shifting the entire graph to another position. Given a constant $c ;(c&gt;0)$, the formulas below show how $c$ moves the graph of $f(x)$: . $f(x)+c$ shifts the graph $c$ units up | $f(x)-c$ shifts the graph $c$ units down | $f(x+c)$ shifts the graph $c$ units to the left | $f(x-c)$ shifts the graph $c$ units to the right | . The whole process can also be represented using a matrix multiplication: . $$ begin{bmatrix} begin{array}{r}1 &amp; 0 &amp; c1 0 &amp; 1 &amp; c2 0 &amp; 0 &amp; 1 end{array} end{bmatrix} cdot begin{bmatrix}x y 1 end{bmatrix} = begin{bmatrix}x+c_1 y+c_2 1 end{bmatrix} $$ def f(x): y = x**2/2 - 2*x - 2 return y x = np.linspace(-10, 10, 1000) fig, ax = plt.subplots() ax.plot(x, f(x), label=&#39;$f(x)$&#39;, c=&#39;black&#39;) ax.plot(x, f(x)+3, label=&#39;$f(x)+3$&#39;, c=&#39;steelblue&#39;) ax.plot(x, f(x-2), label=&#39;$f(x-2)$&#39;, c=&#39;indianred&#39;) ax.quiver( [ 4, 4], [-2, -2], [ 0, 2], [ 3, 0], color=[&#39;steelblue&#39;, &#39;indianred&#39;], scale_units=&#39;xy&#39;, angles=&#39;uv&#39;, scale=1, width=0.005, ) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-3, 9) ax.set_ylim(-5, 5) ax.legend() plt.show() . Dilation . Dilation refers to the process of compressing/stretching the graph. Given a constant $c ;(c&gt;1)$, the formulas below show how $c$ resizes the graph of $f(x)$: . $c cdot f(x)$ stretches the graph $c$ times vertically (in the $y$-direction) | $ displaystyle{ frac{1}{c} cdot f(x)}$ compresses the graph $c$ times vertically (in the $y$-direction) | $f(cx)$ compress the graph $c$ times horizontally (in the $x$-direction) | $ displaystyle{f left( frac{x}{c} right)}$ stretches the graph $c$ times horizontally (in the $x$-direction) | . Note that resizing to a similar shape requires compressing/stretching the same times on both axes. This can be written in matrix form: . $$ begin{bmatrix}c&amp;0 0&amp;c end{bmatrix} cdot begin{bmatrix}x y end{bmatrix} = begin{bmatrix}cx cy end{bmatrix} $$ def f(x): y = 2**x return y x = np.linspace(-10, 10, 1000) fig, ax = plt.subplots() ax.plot(x, f(x), label=&#39;$f(x)$&#39;, c=&#39;black&#39;) ax.plot(x, f(x)/4, label=&#39;$f(x)/4$&#39;, c=&#39;steelblue&#39;) ax.plot(x, f(x*2), label=&#39;$f(2x)$&#39;, c=&#39;indianred&#39;) ax.quiver( [ 2, 2], [ 4, 4], [ 0, -2], [-4, 0], color=[&#39;steelblue&#39;, &#39;indianred&#39;], scale_units=&#39;xy&#39;, angles=&#39;uv&#39;, scale=1, width=0.005, ) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-5, 5) ax.set_ylim(-1, 8) ax.legend() plt.show() . Reflection . Reflection) considers a line as the axis of reflection to map the graph to its image. Here are reflection formulas: . $f(-x)$ results in the graph being reflected across the $y$-axis | $f-(x)$ results in the graph being reflected across the $x$-axis | . The refelection process can also be written as the dot product of a square matrix with the vector $ begin{bmatrix}x y end{bmatrix}$, where each matrix uses a different axis of reflection. For example, $ begin{bmatrix} begin{array}{r}1&amp;0 0&amp;-1 end{array} end{bmatrix}$ for a reflection over $x$-axis, $ begin{bmatrix} begin{array}{r}-1&amp;0 0&amp;1 end{array} end{bmatrix}$ for a reflection over $y$-axis and $ begin{bmatrix}0&amp;1 1&amp;0 end{bmatrix}$ for a reflection over the line $y=x$. . def f(x): y = 2**x return y x = np.linspace(-10, 10, 1000) fig, ax = plt.subplots() ax.plot(x, f(x), label=&#39;$f(x)$&#39;, c=&#39;black&#39;) ax.plot(x, f(-x), label=&#39;$f(-x)$&#39;, c=&#39;steelblue&#39;) ax.plot(x, -f(x), label=&#39;$-f(x)$&#39;, c=&#39;indianred&#39;) ax.quiver( [ 0, 0, 1, 1], [ 2, 2, 0, 0], [ 1, -1, 0, 0], [ 0, 0, 2, -2], color=[&#39;black&#39;, &#39;steelblue&#39;, &#39;black&#39;, &#39;indianred&#39;], scale_units=&#39;xy&#39;, angles=&#39;uv&#39;, scale=1, width=0.005, ) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-4, 4) ax.set_ylim(-4, 4) ax.legend() plt.show() . Rotation . Graph rotation actually means rotating points on the graph one by one. The rotated graph is no longer a function and cannot be represented in the form $y=f(x)$. The formula below shows how to rotate a point about the origin, counterclockwise and by an angle of $ theta$: . $$ begin{aligned} x&#39;=x cos theta-y sin theta y&#39;=x sin theta+y cos theta end{aligned}$$This beautiful formula can also be written using matrix notation as: . $$ begin{bmatrix}x&#39; y&#39; end{bmatrix}= begin{bmatrix} begin{array}{r} cos theta &amp;- sin theta sin theta &amp; cos theta end{array} end{bmatrix} begin{bmatrix}x y end{bmatrix} $$or using complex numbers: . $$ begin{aligned} x&#39;+iy&#39; &amp;= (x cos theta-y sin theta)+i(x sin theta+y cos theta) &amp;= ( cos theta+i sin theta)(x+iy) &amp;= e^{i theta}(x+iy) end{aligned}$$ def rotate(x, y, theta): x_rotated = x*np.cos(theta) - y*np.sin(theta) y_rotated = x*np.sin(theta) + y*np.cos(theta) return x_rotated, y_rotated x = np.linspace(-10, 10, 1000) y = x**2 - 3 theta = np.pi/2 x_rotated, y_rotated = rotate(x, y, theta) fig, ax = plt.subplots() ax.plot(x, y, label=&#39;Original graph&#39;, c=&#39;black&#39;) ax.plot(x_rotated, y_rotated, label=&#39;Rotated graph&#39;, c=&#39;steelblue&#39;) ax.axvline(x=0, c=&#39;grey&#39;) ax.axhline(y=0, c=&#39;grey&#39;) ax.xaxis.set_major_locator(plt.MultipleLocator(1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1)) ax.axis(&#39;scaled&#39;) ax.set_xlim(-4, 4) ax.set_ylim(-4, 4) ax.legend() plt.show() . . &#9829; By Quang Hung x Thuy Linh &#9829; . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://hungpq7.github.io/data-science-blog/jupyter/2020/02/20/graph.html",
            "relUrl": "/jupyter/2020/02/20/graph.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://hungpq7.github.io/data-science-blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://hungpq7.github.io/data-science-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://hungpq7.github.io/data-science-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}